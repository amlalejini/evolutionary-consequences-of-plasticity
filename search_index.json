[["index.html", "Supplemental Material Chapter 1 Introduction", " Supplemental Material Alexander Lalejini, Austin J. Ferguson, and Charles Ofria 2021-01-28 Chapter 1 Introduction TODO "],["validation-experiment.html", "Chapter 2 Validation experiment 2.1 Overview 2.2 Analysis dependencies 2.3 Setup 2.4 Evolution of phenotypic plasticity", " Chapter 2 Validation experiment In this experiment, we validate that (1) we observe the evolution of phenotypic plasticity in a changing environment when digital organisms have access to sensory instructions (capable of differentiating environmental states) and (2) that adaptive phenotypic plasticity does not evolve when populations lack access to sensory instructions. 2.1 Overview total_updates &lt;- 200000 replicates &lt;- 100 all_traits &lt;- c(&quot;not&quot;,&quot;nand&quot;,&quot;and&quot;,&quot;ornot&quot;,&quot;or&quot;,&quot;andnot&quot;) traits_set_a &lt;- c(&quot;not&quot;, &quot;and&quot;, &quot;or&quot;) traits_set_b &lt;- c(&quot;nand&quot;, &quot;ornot&quot;, &quot;andnot&quot;) # Relative location of data. working_directory &lt;- &quot;experiments/2021-01-07-validation/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis We evolved populations of digital organisms under four conditions: A fluctuating environment with access to sensory instructions A fluctuating environment without access to sensory instructions (i.e., sensory instructions are no-operations) A constant environment with access to sensory instructions A constant environment without access to sensory instructions In fluctuating environments, we alternate between rewarding and punishing different sets of computational tasks. In one environment, we reward tasks not, and, or and punish tasks nand, ornot, andnot. In the alternative environment, we reward tasks nand, ornot, andnot and punish tasks not, and, or. In constant environments, we reward all tasks (not, nand, and, ornot, or, andnot). For each replicate of each condition, we extract the dominant (i.e., most numerous) genotype at the end of the run to analyze further. We expect to observe the evolution of adaptive phenotypic plasticity in only the first experimental condition. In conditions without sensors, plasticity in any form should be unable to evolve. 2.2 Analysis dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted/knitted with the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.3 ## year 2020 ## month 10 ## day 10 ## svn rev 79318 ## language R ## version.string R version 4.0.3 (2020-10-10) ## nickname Bunny-Wunnies Freak Out 2.3 Setup data_loc &lt;- paste0(working_directory, &quot;data/aggregate.csv&quot;) data &lt;- read.csv(data_loc, na.strings=&quot;NONE&quot;) data$DISABLE_REACTION_SENSORS &lt;- as.factor(data$DISABLE_REACTION_SENSORS) data$chg_env &lt;- as.factor(data$chg_env) data$dom_plastic_odd_even &lt;- as.factor(data$dom_plastic_odd_even) data$sensors &lt;- data$DISABLE_REACTION_SENSORS == &quot;0&quot; data$is_plastic &lt;- data$dom_plastic_odd_even == &quot;True&quot; env_label_fun &lt;- function(chg_env) { if (chg_env) { return(&quot;Fluctuating&quot;) } else { return(&quot;Constant&quot;) } } sensors_label_fun &lt;- function(has_sensors) { if (has_sensors) { return(&quot;Sensors&quot;) } else { return(&quot;No sensors&quot;) } } # Count observed plasticity for each condition (I&#39;m sure there&#39;s a &#39;tidier&#39; way to do this..) observed_plasticity &lt;- data.frame( environment=character(), sensors=character(), plastic=integer(), nonplastic=integer(), plastic_adaptive=integer(), plastic_optimal=integer(), plastic_nonadaptive=integer() ) for (env_chg in levels(data$chg_env)) { for (disabled_sensors in levels(data$DISABLE_REACTION_SENSORS)) { cond_data &lt;- filter(data, chg_env == env_chg &amp; data$DISABLE_REACTION_SENSORS == disabled_sensors) environment_label &lt;- env_label_fun(env_chg) sensors_label &lt;- sensors_label_fun(disabled_sensors == &quot;0&quot;) observed_plasticity &lt;- observed_plasticity %&gt;% add_row( environment=environment_label, sensors=sensors_label, plastic=nrow(filter(cond_data, is_plastic==TRUE)), nonplastic=nrow(filter(cond_data, is_plastic==FALSE)), plastic_adaptive=nrow(filter(cond_data, dom_adaptive_plasticity==&quot;True&quot;)), plastic_optimal=nrow(filter(cond_data, dom_optimal_plastic==&quot;True&quot;)), plastic_nonadaptive=nrow(filter(cond_data, is_plastic==TRUE &amp; dom_adaptive_plasticity==&quot;False&quot;)) ) } } observed_plasticity &lt;- pivot_longer( observed_plasticity, cols=c(&quot;plastic&quot;, &quot;plastic_adaptive&quot;, &quot;plastic_optimal&quot;, &quot;plastic_nonadaptive&quot;, &quot;nonplastic&quot;), names_to=&quot;phenotype&quot;, values_to=&quot;phenotype_cnt&quot; ) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) 2.4 Evolution of phenotypic plasticity For each experimental condition, do we observe the evolution of phenotypic plasticity? To test for phenotypic plasticity, we culture digital organisms in both environments from the fluctuating condition (including organisms evolved in a constant environment). Any plasticity that we observe from digital organisms evolved under constant conditions is cryptic variation (as these organisms were never exposed to these culturing environments). ggplot(filter(observed_plasticity, phenotype %in% c(&quot;plastic&quot;, &quot;nonplastic&quot;)), aes(x=phenotype, y=phenotype_cnt, fill=phenotype)) + geom_bar( stat=&quot;identity&quot;, position=position_dodge(0.9) ) + geom_text( stat=&quot;identity&quot;, mapping=aes(label=phenotype_cnt), vjust=0.05 ) + scale_fill_brewer(palette=&quot;Accent&quot;) + scale_x_discrete( name=&quot;Phenotype&quot;, limits=c(&quot;plastic&quot;, &quot;nonplastic&quot;), labels=c(&quot;Plastic&quot;, &quot;Non-plastic&quot;) ) + facet_grid(sensors~environment) + theme( legend.position=&quot;none&quot; ) Indeed, we do not observe the evolution of phenotypic plasticity in any replicates in which digital organisms do not have access to sensory instructions. We do observe the evolution of plasticity (not necessarily adaptive plasticity) in both constant and fluctuating environments where sensors are enabled. To what extent is the observed phenotypic plasticity adaptive? ggplot(filter(observed_plasticity, environment==&quot;Fluctuating&quot; &amp; sensors == &quot;Sensors&quot; &amp; phenotype %in% c(&quot;plastic&quot;, &quot;plastic_adaptive&quot;, &quot;plastic_optimal&quot;, &quot;plastic_nonadaptive&quot;)), aes(x=phenotype, y=phenotype_cnt, fill=phenotype)) + geom_bar( stat=&quot;identity&quot;, position=position_dodge(0.9) ) + geom_text( stat=&quot;identity&quot;, mapping=aes(label=phenotype_cnt), vjust=0.05 ) + scale_fill_brewer(palette=&quot;Accent&quot;) + scale_x_discrete( name=&quot;Phenotype&quot;, limits=c(&quot;plastic&quot;, &quot;plastic_adaptive&quot;, &quot;plastic_optimal&quot;, &quot;plastic_nonadaptive&quot;), labels=c(&quot;Total plastic&quot;, &quot;Adaptive plasticity&quot;, &quot;Optimal plasticity&quot;, &quot;Non-adaptive plasticity&quot;) ) + facet_grid(sensors~environment) + theme( legend.position=&quot;none&quot; ) "],["effect-of-phenotypic-plasticity-on-subsequent-evolutionary-dynamics.html", "Chapter 3 Effect of phenotypic plasticity on subsequent evolutionary dynamics 3.1 Overview 3.2 Analysis dependencies 3.3 Setup 3.4 Evolution of phenotypic plasticity 3.5 Phenotypic volatility along dominant lineage 3.6 Mutation accumulation along dominant lineage 3.7 Selective sweeps 3.8 Genome length 3.9 Diversity over time 3.10 Camera-ready figures", " Chapter 3 Effect of phenotypic plasticity on subsequent evolutionary dynamics 3.1 Overview total_updates &lt;- 200000 replicates &lt;- 200 all_traits &lt;- c(&quot;not&quot;,&quot;nand&quot;,&quot;and&quot;,&quot;ornot&quot;,&quot;or&quot;,&quot;andnot&quot;) traits_set_a &lt;- c(&quot;not&quot;, &quot;and&quot;, &quot;or&quot;) traits_set_b &lt;- c(&quot;nand&quot;, &quot;ornot&quot;, &quot;andnot&quot;) # Relative location of data. working_directory &lt;- &quot;experiments/2021-01-12-evo-dynamics/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; # &lt;&lt; For local analysis 3.2 Analysis dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(Hmisc) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted/knitted with the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.3 ## year 2020 ## month 10 ## day 10 ## svn rev 79318 ## language R ## version.string R version 4.0.3 (2020-10-10) ## nickname Bunny-Wunnies Freak Out 3.3 Setup summary_data_loc &lt;- paste0(working_directory, &quot;data/aggregate.csv&quot;) summary_data &lt;- read.csv(summary_data_loc, na.strings=&quot;NONE&quot;) summary_data$DISABLE_REACTION_SENSORS &lt;- as.factor(summary_data$DISABLE_REACTION_SENSORS) summary_data$chg_env &lt;- summary_data$chg_env == &quot;True&quot; summary_data$dominant_plastic_odd_even &lt;- as.factor(summary_data$dominant_plastic_odd_even) summary_data$sensors &lt;- summary_data$DISABLE_REACTION_SENSORS == &quot;0&quot; summary_data$is_plastic &lt;- summary_data$dominant_plastic_odd_even == &quot;True&quot; env_label_fun &lt;- function(chg_env) { if (chg_env) { return(&quot;Fluctuating&quot;) } else { return(&quot;Constant&quot;) } } sensors_label_fun &lt;- function(has_sensors) { if (has_sensors) { return(&quot;Sensors&quot;) } else { return(&quot;No sensors&quot;) } } # note that this labeler makes assumptions about how we set up our experiment condition_label_fun &lt;- function(has_sensors, env_chg) { if (has_sensors &amp;&amp; env_chg) { return(&quot;Plastic (fluctuating)&quot;) } else if (env_chg) { return(&quot;Non-plastic (fluctuating)&quot;) } else { return(&quot;Non-plastic (constant)&quot;) } } summary_data$env_label &lt;- mapply( env_label_fun, summary_data$chg_env ) summary_data$sensors_label &lt;- mapply( sensors_label_fun, summary_data$sensors ) summary_data$condition &lt;- mapply( condition_label_fun, summary_data$sensors, summary_data$chg_env ) condition_order = c( &quot;Non-plastic (constant)&quot;, &quot;Non-plastic (fluctuating)&quot;, &quot;Plastic (fluctuating)&quot; ) ###### time series ##### # time_series_data_loc &lt;- paste0(working_directory, &quot;data/time_series_u0-u200000.csv&quot;) time_series_data_loc &lt;- paste0(working_directory, &quot;data/time_series_u10000-u20000.csv&quot;) time_series_data &lt;- read.csv(time_series_data_loc) time_series_data$DISABLE_REACTION_SENSORS &lt;- as.factor(time_series_data$DISABLE_REACTION_SENSORS) time_series_data$chg_env &lt;- time_series_data$chg_env == &quot;True&quot; time_series_data$sensors &lt;- time_series_data$DISABLE_REACTION_SENSORS == &quot;0&quot; time_series_data$env_label &lt;- mapply( env_label_fun, time_series_data$chg_env ) time_series_data$sensors_label &lt;- mapply( sensors_label_fun, time_series_data$sensors ) time_series_data$condition &lt;- mapply( condition_label_fun, time_series_data$sensors, time_series_data$chg_env ) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) dir.create(paste0(working_directory, &quot;plots&quot;), showWarnings=FALSE) 3.4 Evolution of phenotypic plasticity For sensor-enabled populations in fluctuating environments, we only transfered populations containing an optimally plastic genotype to phase-two. summary_data_grouped = dplyr::group_by(summary_data, sensors, env_label, condition) summary_data_group_counts = dplyr::summarize(summary_data_grouped, n=dplyr::n()) ## `summarise()` has grouped output by &#39;sensors&#39;, &#39;env_label&#39;. You can override using the `.groups` argument. ggplot(summary_data_group_counts, aes(x=condition, y=n, fill=condition)) + geom_col(position=position_dodge(0.9)) + geom_text(aes(label=n, y=n+2)) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Number of replicates in phase two&quot;) + theme( legend.position=&quot;none&quot; ) We can confirm our expectation that the dominant genotypes in non-plastic conditions are not phenotypically plastic. summary_data_grouped = dplyr::group_by(summary_data, condition, is_plastic) summary_data_group_counts = dplyr::summarize(summary_data_grouped, n=dplyr::n()) ## `summarise()` has grouped output by &#39;condition&#39;. You can override using the `.groups` argument. ggplot(filter(summary_data_group_counts, is_plastic), aes(x=condition, y=n, fill=condition)) + geom_col(position=position_dodge(0.9)) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + geom_text(aes(label=n, y=n+1)) + ylab(&quot;Number of replicates with a plastic dominant genotype&quot;) + theme( legend.position=&quot;none&quot; ) 3.5 Phenotypic volatility along dominant lineage ggplot(summary_data, aes(x=condition, y=dominant_lineage_phenotypic_volatility, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Phenotypic volatility&quot;) + theme( legend.position=&quot;none&quot; ) kruskal.test( formula=dominant_lineage_phenotypic_volatility~condition, data=summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: dominant_lineage_phenotypic_volatility by condition ## Kruskal-Wallis chi-squared = 351.93, df = 2, p-value &lt; 2.2e-16 pairwise.wilcox.test( x=summary_data$dominant_lineage_phenotypic_volatility, g=summary_data$condition, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: summary_data$dominant_lineage_phenotypic_volatility and summary_data$condition ## ## Non-plastic (constant) Non-plastic (fluctuating) ## Non-plastic (fluctuating) &lt;2e-16 - ## Plastic (fluctuating) 0.014 &lt;2e-16 ## ## P value adjustment method: bonferroni median(filter(summary_data, condition==&quot;Plastic (fluctuating)&quot;)$dominant_lineage_phenotypic_volatility) ## [1] 391 median(filter(summary_data, condition==&quot;Non-plastic (constant)&quot;)$dominant_lineage_phenotypic_volatility) ## [1] 356 median(filter(summary_data, condition==&quot;Non-plastic (fluctuating)&quot;)$dominant_lineage_phenotypic_volatility) ## [1] 1628 3.6 Mutation accumulation along dominant lineage ggplot(summary_data, aes(x=condition, y=dominant_lineage_total_mut_cnt, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Mutation accumulation&quot;) + theme( legend.position=&quot;none&quot; ) kruskal.test( formula=dominant_lineage_total_mut_cnt~condition, data=summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: dominant_lineage_total_mut_cnt by condition ## Kruskal-Wallis chi-squared = 352.67, df = 2, p-value &lt; 2.2e-16 pairwise.wilcox.test( x=summary_data$dominant_lineage_total_mut_cnt, g=summary_data$condition, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: summary_data$dominant_lineage_total_mut_cnt and summary_data$condition ## ## Non-plastic (constant) Non-plastic (fluctuating) ## Non-plastic (fluctuating) &lt;2e-16 - ## Plastic (fluctuating) 0.65 &lt;2e-16 ## ## P value adjustment method: bonferroni median(filter(summary_data, condition==&quot;Plastic (fluctuating)&quot;)$dominant_lineage_total_mut_cnt) ## [1] 1833 median(filter(summary_data, condition==&quot;Non-plastic (constant)&quot;)$dominant_lineage_total_mut_cnt) ## [1] 1823.5 median(filter(summary_data, condition==&quot;Non-plastic (fluctuating)&quot;)$dominant_lineage_total_mut_cnt) ## [1] 11721 3.6.1 Mutation accumulation normalized by lineage length summary_data$mutations_per_lineage_step &lt;- summary_data$dominant_lineage_total_mut_cnt / summary_data$dominant_lineage_length_genotypes ggplot(summary_data, aes(x=condition, y=mutations_per_lineage_step, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Mutation accumulation / lineage length&quot;) + theme( legend.position=&quot;none&quot; ) kruskal.test( formula=mutations_per_lineage_step~condition, data=summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: mutations_per_lineage_step by condition ## Kruskal-Wallis chi-squared = 194.32, df = 2, p-value &lt; 2.2e-16 pairwise.wilcox.test( x=summary_data$mutations_per_lineage_step, g=summary_data$condition, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: summary_data$mutations_per_lineage_step and summary_data$condition ## ## Non-plastic (constant) Non-plastic (fluctuating) ## Non-plastic (fluctuating) &lt;2e-16 - ## Plastic (fluctuating) 1 &lt;2e-16 ## ## P value adjustment method: bonferroni median(filter(summary_data, condition==&quot;Plastic (fluctuating)&quot;)$mutations_per_lineage_step) ## [1] 1.504491 median(filter(summary_data, condition==&quot;Non-plastic (constant)&quot;)$mutations_per_lineage_step) ## [1] 1.526001 median(filter(summary_data, condition==&quot;Non-plastic (fluctuating)&quot;)$mutations_per_lineage_step) ## [1] 2.645598 3.7 Selective sweeps The number of times the most recent common ancestor changes gives us the number of selective sweeps that occur during the experiment. ggplot(summary_data, aes(x=condition, y=phylo_mrca_changes, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Number of selective sweeps&quot;) + theme( legend.position=&quot;none&quot; ) kruskal.test( formula=phylo_mrca_changes~condition, data=summary_data ) ## ## Kruskal-Wallis rank sum test ## ## data: phylo_mrca_changes by condition ## Kruskal-Wallis chi-squared = 182.92, df = 2, p-value &lt; 2.2e-16 pairwise.wilcox.test( x=summary_data$phylo_mrca_changes, g=summary_data$condition, p.adjust.method=&quot;bonferroni&quot;, ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: summary_data$phylo_mrca_changes and summary_data$condition ## ## Non-plastic (constant) Non-plastic (fluctuating) ## Non-plastic (fluctuating) &lt;2e-16 - ## Plastic (fluctuating) 0.35 &lt;2e-16 ## ## P value adjustment method: bonferroni median(filter(summary_data, condition==&quot;Plastic (fluctuating)&quot;)$phylo_mrca_changes) ## [1] 49 median(filter(summary_data, condition==&quot;Non-plastic (constant)&quot;)$phylo_mrca_changes) ## [1] 47 median(filter(summary_data, condition==&quot;Non-plastic (fluctuating)&quot;)$phylo_mrca_changes) ## [1] 288.5 3.8 Genome length ggplot(summary_data, aes(x=condition, y=dominant_genome_length, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Genome length&quot;) + theme( legend.position=&quot;none&quot; ) 3.9 Diversity over time 3.9.1 Shannon entropy over time # shannon entropy ggplot(time_series_data, aes(x=update, y=phylo_diversity, fill=condition, color=condition)) + stat_summary(fun=&quot;mean&quot;, geom=&quot;line&quot;) + stat_summary( fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), geom=&quot;ribbon&quot;, alpha=0.2, linetype=0 ) + ylab(&quot;Shannon entropy&quot;) Zoom in to just 400 update span. # shannon entropy ggplot(filter(time_series_data, update &lt;= 10400), aes(x=update, y=phylo_diversity, fill=condition, color=condition)) + stat_summary(fun=&quot;mean&quot;, geom=&quot;line&quot;) + stat_summary( fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), geom=&quot;ribbon&quot;, alpha=0.2, linetype=0 ) + ylab(&quot;Shannon entropy&quot;) 3.9.2 Phylogenetic diversity over time // From (Faith 1992, reviewed in Winters et al., 2013), phylogenetic diversity is the sum of edges in the minimal spanning tree connected the taxa you&#39;re calculating diversity of. // This calculates phylogenetic diversity for all extant taxa in the tree. ggplot(time_series_data, aes(x=update, y=phylo_current_phylogenetic_diversity, fill=condition, color=condition)) + stat_summary(fun=&quot;mean&quot;, geom=&quot;line&quot;) + stat_summary( fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), geom=&quot;ribbon&quot;, alpha=0.2, linetype=0 ) + ylab(&quot;Phylogenetic diversity&quot;) 3.9.3 Number of extant taxa (genotypes) over time ggplot(time_series_data, aes(x=update, y=phylo_num_taxa_extant, fill=condition, color=condition)) + stat_summary(fun=&quot;mean&quot;, geom=&quot;line&quot;) + stat_summary( fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), geom=&quot;ribbon&quot;, alpha=0.2, linetype=0 ) 3.10 Camera-ready figures Figures styled for the paper. Mutation accumulation library(viridis) ## Loading required package: viridisLite library(RColorBrewer) # dominant_lineage_total_mut_cnt or mutations_per_lineage_step? mutation_count_fig &lt;- ggplot( summary_data, aes(x=condition, y=dominant_lineage_total_mut_cnt, fill=condition) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order, labels=c( &quot;Constant env.&quot;, &quot;Fluct. env.\\nnon-plastic&quot;, &quot;Fluct. env.\\nplastic&quot; ) ) + scale_y_continuous( name=&quot;Mutations accumulated (log scale)&quot;, trans=&quot;log10&quot; ) + scale_fill_brewer( palette=&quot;Paired&quot; ) + scale_color_brewer( palette=&quot;Paired&quot; ) + theme( legend.position=&quot;none&quot; ) + coord_flip() + ggsave( paste0(working_directory, &quot;plots/&quot;, &quot;mutation-accumulation.pdf&quot;), width=5, height=4 ) Phenotypic volatility phenotypic_volatility_fig &lt;- ggplot( summary_data, aes(x=condition, y=dominant_lineage_phenotypic_volatility, fill=condition) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order, labels=c( &quot;Constant env.&quot;, &quot;Fluct. env.\\nnon-plastic&quot;, &quot;Fluct. env.\\nplastic&quot; ) ) + scale_y_continuous( name=&quot;Phenotypic volatility (log scale)&quot;, trans=&quot;log10&quot;, limits=c(50,11000) ) + scale_fill_brewer( palette=&quot;Paired&quot; ) + scale_color_brewer( palette=&quot;Paired&quot; ) + theme( legend.position=&quot;none&quot;, axis.ticks.y=element_blank(), axis.text.y=element_blank(), axis.title.y=element_blank() ) + coord_flip() + ggsave( paste0(working_directory, &quot;plots/&quot;, &quot;phenotypic-volatility.pdf&quot;), width=4, height=4 ) Selective sweeps. selective_sweeps_fig &lt;- ggplot( summary_data, aes(x=condition, y=phylo_mrca_changes, fill=condition) ) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order, labels=c( &quot;Constant env.&quot;, &quot;Fluct. env.\\nnon-plastic&quot;, &quot;Fluct. env.\\nplastic&quot; ) ) + scale_y_continuous( name=&quot;Selective sweeps (log scale)&quot;, trans=&quot;log10&quot; ) + scale_fill_brewer( palette=&quot;Paired&quot; ) + scale_color_brewer( palette=&quot;Paired&quot; ) + theme( legend.position=&quot;none&quot;, axis.ticks.y=element_blank(), axis.text.y=element_blank(), axis.title.y=element_blank() ) + coord_flip() + ggsave( paste0(working_directory, &quot;plots/&quot;, &quot;selective-sweeps.pdf&quot;), width=4, height=4 ) # nrow(filter(summary_data, condition==&quot;Non-plastic (fluctuating)&quot; &amp; phylo_mrca_changes &lt;= 1)) All together grid &lt;- plot_grid( mutation_count_fig, phenotypic_volatility_fig, selective_sweeps_fig, nrow=1, align=&quot;v&quot;, labels=&quot;auto&quot; ) save_plot( paste0(working_directory, &quot;plots/&quot;, &quot;evolutionary-dynamics.pdf&quot;), grid, base_height=6, base_asp=2.5 ) # ggsave( # paste0(working_directory, &quot;plots/&quot;, &quot;evolutionary-dynamics.pdf&quot;), # width=10, # height=8 # ) "],["effect-of-phenotypic-plasticity-on-the-evolution-and-maintenance-of-complex-features.html", "Chapter 4 Effect of phenotypic plasticity on the evolution and maintenance of complex features 4.1 Overview 4.2 Analysis dependencies 4.3 Setup 4.4 Evolution of phenotypic plasticity 4.5 Genome length 4.6 Extra task performance at the end of the experiment (dominant) 4.7 Extra tasks along lineage of final dominant genotype 4.8 Extra task performance over time", " Chapter 4 Effect of phenotypic plasticity on the evolution and maintenance of complex features 4.1 Overview total_updates &lt;- 200000 replicates &lt;- 200 focal_traits &lt;- c(&quot;not&quot;,&quot;nand&quot;,&quot;and&quot;,&quot;ornot&quot;,&quot;or&quot;,&quot;andnot&quot;) traits_set_a &lt;- c(&quot;not&quot;, &quot;and&quot;, &quot;or&quot;) traits_set_b &lt;- c(&quot;nand&quot;, &quot;ornot&quot;, &quot;andnot&quot;) extra_traits &lt;- c( &quot;nor&quot;,&quot;xor&quot;,&quot;equals&quot;, &quot;logic_3aa&quot;,&quot;logic_3ab&quot;,&quot;logic_3ac&quot;, &quot;logic_3ad&quot;,&quot;logic_3ae&quot;,&quot;logic_3af&quot;, &quot;logic_3ag&quot;,&quot;logic_3ah&quot;,&quot;logic_3ai&quot;, &quot;logic_3aj&quot;,&quot;logic_3ak&quot;,&quot;logic_3al&quot;, &quot;logic_3am&quot;,&quot;logic_3an&quot;,&quot;logic_3ao&quot;, &quot;logic_3ap&quot;,&quot;logic_3aq&quot;,&quot;logic_3ar&quot;, &quot;logic_3as&quot;,&quot;logic_3at&quot;,&quot;logic_3au&quot;, &quot;logic_3av&quot;,&quot;logic_3aw&quot;,&quot;logic_3ax&quot;, &quot;logic_3ay&quot;,&quot;logic_3az&quot;,&quot;logic_3ba&quot;, &quot;logic_3bb&quot;,&quot;logic_3bc&quot;,&quot;logic_3bd&quot;, &quot;logic_3be&quot;,&quot;logic_3bf&quot;,&quot;logic_3bg&quot;, &quot;logic_3bh&quot;,&quot;logic_3bi&quot;,&quot;logic_3bj&quot;, &quot;logic_3bk&quot;,&quot;logic_3bl&quot;,&quot;logic_3bm&quot;, &quot;logic_3bn&quot;,&quot;logic_3bo&quot;,&quot;logic_3bp&quot;, &quot;logic_3bq&quot;,&quot;logic_3br&quot;,&quot;logic_3bs&quot;, &quot;logic_3bt&quot;,&quot;logic_3bu&quot;,&quot;logic_3bv&quot;, &quot;logic_3bw&quot;,&quot;logic_3bx&quot;,&quot;logic_3by&quot;, &quot;logic_3bz&quot;,&quot;logic_3ca&quot;,&quot;logic_3cb&quot;, &quot;logic_3cc&quot;,&quot;logic_3cd&quot;,&quot;logic_3ce&quot;, &quot;logic_3cf&quot;,&quot;logic_3cg&quot;,&quot;logic_3ch&quot;, &quot;logic_3ci&quot;,&quot;logic_3cj&quot;,&quot;logic_3ck&quot;, &quot;logic_3cl&quot;,&quot;logic_3cm&quot;,&quot;logic_3cn&quot;, &quot;logic_3co&quot;,&quot;logic_3cp&quot; ) # Relative location of data. working_directory &lt;- &quot;experiments/2021-01-14-complex-features/analysis/&quot; # &lt;&lt; For bookdown # working_directory &lt;- &quot;./&quot; 4.2 Analysis dependencies Load all required R libraries. library(ggplot2) library(tidyverse) library(cowplot) library(Hmisc) source(&quot;https://gist.githubusercontent.com/benmarwick/2a1bb0133ff568cbe28d/raw/fb53bd97121f7f9ce947837ef1a4c65a73bffb3f/geom_flat_violin.R&quot;) These analyses were conducted/knitted with the following computing environment: print(version) ## _ ## platform x86_64-pc-linux-gnu ## arch x86_64 ## os linux-gnu ## system x86_64, linux-gnu ## status ## major 4 ## minor 0.3 ## year 2020 ## month 10 ## day 10 ## svn rev 79318 ## language R ## version.string R version 4.0.3 (2020-10-10) ## nickname Bunny-Wunnies Freak Out 4.3 Setup ####### summary data ####### summary_data_loc &lt;- paste0(working_directory, &quot;data/aggregate.csv&quot;) summary_data &lt;- read.csv(summary_data_loc, na.strings=&quot;NONE&quot;) summary_data$DISABLE_REACTION_SENSORS &lt;- as.factor(summary_data$DISABLE_REACTION_SENSORS) summary_data$chg_env &lt;- summary_data$chg_env == &quot;True&quot; summary_data$dominant_plastic_odd_even &lt;- as.factor(summary_data$dominant_plastic_odd_even) summary_data$sensors &lt;- summary_data$DISABLE_REACTION_SENSORS == &quot;0&quot; summary_data$is_plastic &lt;- summary_data$dominant_plastic_odd_even == &quot;True&quot; summary_data$extra_task_value &lt;- as.factor(summary_data$extra_task_value) env_label_fun &lt;- function(chg_env) { if (chg_env) { return(&quot;Fluctuating&quot;) } else { return(&quot;Constant&quot;) } } sensors_label_fun &lt;- function(has_sensors) { if (has_sensors) { return(&quot;Sensors&quot;) } else { return(&quot;No sensors&quot;) } } condition_label_fun &lt;- function(has_sensors, env_chg) { if (has_sensors &amp;&amp; env_chg) { return(&quot;Plastic (fluctuating)&quot;) } else if (env_chg) { return(&quot;Non-plastic (fluctuating)&quot;) } else { return(&quot;Non-plastic (constant)&quot;) } } summary_data$env_label &lt;- mapply( env_label_fun, summary_data$chg_env ) summary_data$sensors_label &lt;- mapply( sensors_label_fun, summary_data$sensors ) summary_data$condition &lt;- mapply( condition_label_fun, summary_data$sensors, summary_data$chg_env ) condition_order = c( &quot;Non-plastic (constant)&quot;, &quot;Non-plastic (fluctuating)&quot;, &quot;Plastic (fluctuating)&quot; ) ###### time series ##### lineage_time_series_data_loc &lt;- paste0(working_directory, &quot;data/lineage_series.csv&quot;) lineage_time_series_data &lt;- read.csv(lineage_time_series_data_loc) lineage_time_series_data$DISABLE_REACTION_SENSORS &lt;- as.factor(lineage_time_series_data$DISABLE_REACTION_SENSORS) lineage_time_series_data$chg_env &lt;- lineage_time_series_data$chg_env == &quot;True&quot; lineage_time_series_data$sensors &lt;- lineage_time_series_data$DISABLE_REACTION_SENSORS == &quot;0&quot; lineage_time_series_data$extra_task_value &lt;- as.factor(lineage_time_series_data$extra_task_value) lineage_time_series_data$env_label &lt;- mapply( env_label_fun, lineage_time_series_data$chg_env ) lineage_time_series_data$sensors_label &lt;- mapply( sensors_label_fun, lineage_time_series_data$sensors ) lineage_time_series_data$condition &lt;- mapply( condition_label_fun, lineage_time_series_data$sensors, lineage_time_series_data$chg_env ) ####### misc ####### # Configure our default graphing theme theme_set(theme_cowplot()) dir.create(paste0(working_directory, &quot;plots&quot;), showWarnings=FALSE) 4.4 Evolution of phenotypic plasticity For sensor-enabled populations in fluctuating environments, we only transfered populations containing an optimally plastic genotype to phase-two. summary_data_grouped = dplyr::group_by(summary_data, sensors, env_label, condition, extra_task_value) summary_data_group_counts = dplyr::summarize(summary_data_grouped, n=dplyr::n()) ## `summarise()` has grouped output by &#39;sensors&#39;, &#39;env_label&#39;, &#39;condition&#39;. You can override using the `.groups` argument. ggplot(summary_data_group_counts, aes(x=condition, y=n, fill=condition)) + geom_col(position=position_dodge(0.9)) + geom_text(aes(label=n, y=n+2)) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Number of replicates in phase two&quot;) + facet_wrap(~extra_task_value, labeller=label_both) + theme( legend.position=&quot;none&quot; ) We can confirm our expectation that the dominant genotypes in non-plastic conditions are not phenotypically plastic. summary_data_grouped = dplyr::group_by(summary_data, condition, is_plastic, extra_task_value) summary_data_group_counts = dplyr::summarize(summary_data_grouped, n=dplyr::n()) ## `summarise()` has grouped output by &#39;condition&#39;, &#39;is_plastic&#39;. You can override using the `.groups` argument. ggplot(filter(summary_data_group_counts, is_plastic), aes(x=condition, y=n, fill=condition)) + geom_col(position=position_dodge(0.9)) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + geom_text(aes(label=n, y=n+1)) + ylab(&quot;Number of replicates with a plastic dominant genotype&quot;) + facet_wrap(~extra_task_value, labeller=label_both) + theme( legend.position=&quot;none&quot; ) 4.5 Genome length ggplot(summary_data, aes(x=condition, y=dominant_genome_length, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Genome length of final dominant&quot;) + facet_wrap( ~extra_task_value, labeller=label_both ) + theme( legend.position=&quot;none&quot; ) 4.6 Extra task performance at the end of the experiment (dominant) ggplot(summary_data, aes(x=condition, y=dominant_extra_tasks, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Extra traits final dominant&quot;) + facet_wrap( ~extra_task_value, labeller=label_both ) + theme( legend.position=&quot;none&quot; ) + ggsave( paste0(working_directory, &quot;plots/dominant-extra-tasks.pdf&quot;), width=15, height=10 ) pop_threshold &lt;- 0.3 dom_task_data &lt;- filter(summary_data, extra_task_value==pop_threshold) kruskal.test( formula=dominant_extra_tasks~condition, data=dom_task_data ) ## ## Kruskal-Wallis rank sum test ## ## data: dominant_extra_tasks by condition ## Kruskal-Wallis chi-squared = 14.215, df = 2, p-value = 0.0008188 pairwise.wilcox.test( x=dom_task_data$dominant_extra_tasks, g=dom_task_data$condition, p.adjust.method=&quot;bonferroni&quot;, conf.int=TRUE, conf.level=0.95 ) ## ## Pairwise comparisons using Wilcoxon rank sum test with continuity correction ## ## data: dom_task_data$dominant_extra_tasks and dom_task_data$condition ## ## Non-plastic (constant) Non-plastic (fluctuating) ## Non-plastic (fluctuating) 1.000 - ## Plastic (fluctuating) 0.016 1e-04 ## ## P value adjustment method: bonferroni 4.7 Extra tasks along lineage of final dominant genotype 4.7.1 Tasks discovered ggplot(summary_data, aes(x=condition, y=dominant_lineage_extra_traits_discovered, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Extra tasks discovered along dominant lineage&quot;) + facet_wrap( ~extra_task_value, labeller=label_both ) + theme( legend.position=&quot;none&quot; ) + ggsave( paste0(working_directory, &quot;plots/dominant-lineage-extra-tasks-discovered.pdf&quot;), width=15, height=10 ) 4.7.2 Tasks gained ggplot(summary_data, aes(x=condition, y=dominant_lineage_extra_traits_gained, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Extra tasks gained along dominant lineage&quot;) + facet_wrap( ~extra_task_value, labeller=label_both ) + theme( legend.position=&quot;none&quot; ) + ggsave( paste0(working_directory, &quot;plots/dominant-lineage-extra-tasks-gained.pdf&quot;), width=15, height=10 ) 4.7.3 Tasks lost ggplot(summary_data, aes(x=condition, y=dominant_lineage_extra_traits_lost, fill=condition)) + geom_flat_violin( position = position_nudge(x = .2, y = 0), alpha = .8 ) + geom_point( mapping=aes(color=condition), position = position_jitter(width = .15), size = .5, alpha = 0.8 ) + geom_boxplot( width = .1, outlier.shape = NA, alpha = 0.5 ) + scale_x_discrete( name=&quot;Condition&quot;, limits=condition_order ) + ylab(&quot;Extra tasks lost along dominant lineage&quot;) + facet_wrap( ~extra_task_value, labeller=label_both ) + theme( legend.position=&quot;none&quot; ) + ggsave( paste0(working_directory, &quot;plots/dominant-lineage-extra-tasks-lost.pdf&quot;), width=15, height=10 ) 4.8 Extra task performance over time Match score over time lineage_reward30 &lt;- filter(lineage_time_series_data, extra_task_value==&quot;0.3&quot;) lineage_reward10 &lt;- filter(lineage_time_series_data, extra_task_value==&quot;0.1&quot;) ggplot(filter(lineage_reward30, update&gt;198000 &amp; update&lt;=200000), aes(x=update, y=match_score_even, color=condition, fill=condition)) + stat_summary(fun=&quot;mean&quot;, geom=&quot;line&quot;) + stat_summary( fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), geom=&quot;ribbon&quot;, alpha=0.2, linetype=0 ) + ylab(&quot;Match score (even environment)&quot;) + facet_wrap( ~extra_task_value, labeller=label_both ) + ggsave( paste0(working_directory, &quot;plots/dominant-lineage-match-score-even-val30.png&quot;), width=15, height=10 ) ggplot(filter(lineage_reward10, update&gt;198000 &amp; update&lt;=200000), aes(x=update, y=match_score_even, color=condition, fill=condition)) + stat_summary(fun=&quot;mean&quot;, geom=&quot;line&quot;) + stat_summary( fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), geom=&quot;ribbon&quot;, alpha=0.2, linetype=0 ) + ylab(&quot;Match score (even environment)&quot;) + facet_wrap( ~extra_task_value, labeller=label_both ) + ggsave( paste0(working_directory, &quot;plots/dominant-lineage-match-score-even-val10.png&quot;), width=15, height=10 ) Extra tasks over time ggplot(filter(lineage_reward30, update&gt;198000 &amp; update&lt;=200000), aes(x=update, y=extra_traits, color=condition, fill=condition)) + stat_summary(fun=&quot;mean&quot;, geom=&quot;line&quot;) + stat_summary( fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), geom=&quot;ribbon&quot;, alpha=0.2, linetype=0 ) + ylab(&quot;Match score (even environment)&quot;) + facet_wrap( ~extra_task_value, labeller=label_both ) + ggsave( paste0(working_directory, &quot;plots/dominant-lineage-extra-traits-val30.png&quot;), width=15, height=10 ) ggplot(filter(lineage_reward10, update&gt;198000 &amp; update&lt;=200000), aes(x=update, y=extra_traits, color=condition, fill=condition)) + stat_summary(fun=&quot;mean&quot;, geom=&quot;line&quot;) + stat_summary( fun.data=&quot;mean_cl_boot&quot;, fun.args=list(conf.int=0.95), geom=&quot;ribbon&quot;, alpha=0.2, linetype=0 ) + ylab(&quot;Match score (even environment)&quot;) + facet_wrap( ~extra_task_value, labeller=label_both ) + ggsave( paste0(working_directory, &quot;plots/dominant-lineage-extra-traits-val10.png&quot;), width=15, height=10 ) "],["references.html", "References", " References "]]
